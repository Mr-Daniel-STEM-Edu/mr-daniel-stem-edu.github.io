<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="The Nouveau Way Simulation Hub - Interactive Physics and STEM Simulations.">
  <meta name="author" content="Mr. Daniel Bishoy">
  <title>The Nouveau Way Simulation Hub</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700;800;900&family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

  <script src="https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/animejs@3/lib/anime.min.js"></script>

  <style>
    :root {
      --primary: #4361ee;
      --primary-soft: rgba(67, 97, 238, 0.1);
      --nu-gradient: linear-gradient(135deg, #4361ee, #4cc9f0);
      --bg: #f8fafc;
      --text: #1e293b;
      --text-muted: #64748b;
      --border: #e2e8f0;
      --glass: rgba(255, 255, 255, 0.9);
    }
    
    * { box-sizing: border-box; }
    body { margin:0; font-family:'Inter',sans-serif; background:var(--bg); color:var(--text); line-height: 1.6; }

    /* HEADER */
    .nouveau-header {
      position: sticky; top: 0; z-index: 1000;
      background: var(--glass); backdrop-filter: blur(12px);
      border-bottom: 1px solid var(--border);
      padding: 0.75rem 0;
    }
    .header-bar {
      max-width: 1200px; margin: 0 auto; padding: 0 1.5rem;
      display: flex; justify-content: space-between; align-items: center;
    }
    .logo-area { display: flex; align-items: center; gap: 1rem; text-decoration: none; color: inherit; }
    .logo-box {
      width: 42px; height: 42px; background: var(--nu-gradient);
      border-radius: 12px; color: white; display: grid; place-items: center; font-size: 1.2rem;
    }
    .brand-name { font-family: 'Outfit', sans-serif; font-weight: 800; font-size: 1.5rem; letter-spacing: -0.02em; }
    
    .back-btn {
      display: inline-flex; align-items: center; gap: 0.5rem;
      padding: 0.6rem 1.2rem; border-radius: 12px;
      text-decoration: none; font-weight: 600; font-size: 0.9rem;
      background: white; border: 1px solid var(--border); color: var(--text);
      transition: all 0.3s ease;
    }
    .back-btn:hover { border-color: var(--primary); color: var(--primary); transform: translateX(-2px); }

    /* HERO */
    .hero {
      text-align: center; padding: 6rem 1.5rem 4rem;
      max-width: 900px; margin: 0 auto;
    }
    .hero h1 { font-family: 'Outfit', sans-serif; font-size: 3.5rem; font-weight: 800; margin-bottom: 1.5rem; line-height: 1.1; }
    .hero p { font-size: 1.25rem; color: var(--text-muted); max-width: 700px; margin: 0 auto 3rem; }

    /* GLOWING BUTTON */
    .glowing-btn {
      display: inline-flex; align-items: center; gap: 1rem;
      padding: 1.2rem 3rem; border-radius: 50px;
      background: var(--nu-gradient); color: white;
      font-weight: 700; font-size: 1.2rem; text-decoration: none;
      animation: pulse 2s infinite; transition: transform 0.3s;
    }
    .glowing-btn:hover { transform: translateY(-2px); animation: none; box-shadow: 0 10px 40px -10px rgba(67,97,238,0.6); }
    @keyframes pulse {
      0% { box-shadow: 0 0 0 0 rgba(67, 97, 238, 0.7); }
      70% { box-shadow: 0 0 0 15px rgba(67, 97, 238, 0); }
      100% { box-shadow: 0 0 0 0 rgba(67, 97, 238, 0); }
    }

    /* SIMULATION ROWS */
    .sim-container { max-width: 1200px; margin: 0 auto; padding: 2rem 1.5rem; }
    .sim-row {
      display: flex; flex-direction: column; gap: 2rem; margin-bottom: 6rem;
      border-top: 1px dashed var(--border); padding-top: 4rem;
    }
    .sim-row:first-child { border-top: none; }
    
    @media(min-width: 992px) {
      .sim-row { flex-direction: row; align-items: center; gap: 4rem; }
      .sim-row:nth-child(even) { flex-direction: row-reverse; }
    }

    .sim-info { flex: 1; }
    .sim-info h2 { font-family: 'Outfit', sans-serif; margin: 0.5rem 0 1rem; font-size: 2.25rem; font-weight: 800; }
    .sim-tag { 
      display: inline-block; background: var(--primary-soft); color: var(--primary); 
      padding: 0.4rem 1rem; border-radius: 20px; font-weight: 600; font-size: 0.85rem; margin-bottom: 0.5rem;
    }
    
    /* CANVAS BOX */
    .canvas-box {
      flex: 1.5; background: #0f172a; border-radius: 24px; 
      aspect-ratio: 16/9; position: relative; overflow: hidden;
      box-shadow: 0 20px 25px -5px rgba(0,0,0,0.1);
      display: flex; align-items: center; justify-content: center;
    }
    /* Grid Pattern Overlay */
    .canvas-box::before {
      content: ''; position: absolute; inset:0; pointer-events: none;
      background-image: linear-gradient(rgba(255,255,255,0.05) 1px, transparent 1px), linear-gradient(90deg, rgba(255,255,255,0.05) 1px, transparent 1px);
      background-size: 20px 20px;
    }
    canvas { display: block; width: 100%; height: 100%; position: relative; z-index: 1; }

    /* HUD */
    .hud {
      position: absolute; top: 15px; left: 15px; pointer-events: none;
      font-family: 'Courier New', monospace; font-weight: bold; font-size: 13px;
      color: rgba(255,255,255,0.9); text-shadow: 0 2px 4px rgba(0,0,0,0.8);
      white-space: pre-line; z-index: 10;
    }

    /* CONTROLS */
    .controls {
      margin-top: 1.5rem; background: #fff; padding: 1.5rem;
      border: 1px solid var(--border); border-radius: 12px;
      box-shadow: 0 4px 6px -1px rgba(0,0,0,0.02);
    }
    .ctrl-group { margin-bottom: 1rem; }
    
    /* FIXED: Better spacing for values */
    .ctrl-header { 
      display: flex; justify-content: space-between; align-items: center;
      font-weight: 600; font-size: 0.9rem; margin-bottom: 0.5rem; color: var(--text); 
    }
    .ctrl-val { 
      font-family: 'Courier New', monospace; color: var(--primary); 
      font-weight: 700; background: var(--primary-soft); 
      padding: 2px 8px; border-radius: 6px;
    }
    
    input[type=range] { width: 100%; accent-color: var(--primary); cursor: pointer; height: 6px; border-radius: 3px; }
    
    button.btn-primary {
      width: 100%; padding: 12px; background: var(--primary); color: white;
      border: none; border-radius: 8px; font-weight: 700; cursor: pointer; font-size: 0.95rem;
      transition: opacity 0.2s;
    }
    button.btn-primary:hover { opacity: 0.9; }

    footer { text-align: center; padding: 3rem; border-top: 1px solid var(--border); margin-top: 4rem; background: #fff; }
  </style>
</head>
<body>

  <header class="nouveau-header">
    <div class="header-bar">
      <a href="#" class="logo-area">
        <div class="logo-box"><i class="fas fa-atom"></i></div>
        <span class="brand-name">The Nouveau Way</span>
      </a>
      <a href="https://mr-daniel.online" class="back-btn">
        <i class="fas fa-arrow-left"></i> Back to mr-daniel.online
      </a>
    </div>
  </header>

  <main>
    <section class="hero">
      <h1 class="animate-in">Interactive Physics<br><span style="color: var(--primary);">Simulation Hub</span></h1>
      <p class="animate-in">Experience the laws of the universe directly in your browser. Powered by Matter.js, Three.js, and advanced math engines.</p>
      
      <a href="#simulations-start" class="glowing-btn animate-in">
        <i class="fas fa-play"></i> Explore Simulations
      </a>
    </section>

    <div id="simulations-start" class="sim-container">

      <section class="sim-row">
        <div class="sim-info">
          <span class="sim-tag">Matter.js</span>
          <h2>Projectile Motion</h2>
          <p>Real-time kinematics. Observe how angle $\theta$ and velocity $v_0$ affect the parabolic trajectory according to $y = x\tan\theta - \frac{gx^2}{2v_0^2\cos^2\theta}$.</p>
          <div id="ctrl-projectile" class="controls"></div>
        </div>
        <div class="canvas-box">
          <div id="hud-projectile" class="hud"></div>
          <canvas id="canvas-projectile"></canvas>
        </div>
      </section>

      <section class="sim-row">
        <div class="sim-info">
          <span class="sim-tag">Physics Engine</span>
          <h2>Wave Interference</h2>
          <p>Superposition principle. Two continuous sources create constructive ($n\lambda$) and destructive ($(n+0.5)\lambda$) interference patterns.</p>
          <div id="ctrl-wave" class="controls"></div>
        </div>
        <div class="canvas-box">
          <div id="hud-wave" class="hud"></div>
          <canvas id="canvas-wave"></canvas>
        </div>
      </section>

      <section class="sim-row">
        <div class="sim-info">
          <span class="sim-tag">Three.js 3D</span>
          <h2>Orbital Mechanics</h2>
          <p>Newtonian gravity ($F = G\frac{M m}{r^2}$) in 3D. A planet orbiting a massive star in a frictionless vacuum.</p>
          <div id="ctrl-orbit" class="controls"></div>
        </div>
        <div class="canvas-box">
          <div id="hud-orbit" class="hud"></div>
          <canvas id="canvas-orbit"></canvas>
        </div>
      </section>

      <section class="sim-row">
        <div class="sim-info">
          <span class="sim-tag">Logic Solver</span>
          <h2>DC Circuit Builder</h2>
          <p>Ohm's Law ($V=IR$) visualization. Adjust resistance $R$ and voltage $V$ to observe the change in current flow $I$.</p>
          <div id="ctrl-circuit" class="controls"></div>
        </div>
        <div class="canvas-box">
          <div id="hud-circuit" class="hud"></div>
          <canvas id="canvas-circuit"></canvas>
        </div>
      </section>

      <section class="sim-row">
        <div class="sim-info">
          <span class="sim-tag">Vector Fields</span>
          <h2>Electromagnetic Fields</h2>
          <p>Ampere's Law visualization ($B = \mu_0 n I$). The magnetic field inside a solenoid is uniform, while the outside field loops from North to South.</p>
          <div id="ctrl-em" class="controls"></div>
        </div>
        <div class="canvas-box">
          <div id="hud-em" class="hud"></div>
          <canvas id="canvas-em"></canvas>
        </div>
      </section>

      <section class="sim-row">
        <div class="sim-info">
          <span class="sim-tag">RK4 Integrator</span>
          <h2>Damped Harmonic Motion</h2>
          <p>Numerical solution of the differential equation $m\ddot{x} + c\dot{x} + kx = 0$. Visualizing damping ratios $\zeta$.</p>
          <div id="ctrl-harmonic" class="controls"></div>
        </div>
        <div class="canvas-box">
          <div id="hud-harmonic" class="hud"></div>
          <canvas id="canvas-harmonic"></canvas>
        </div>
      </section>

      <section class="sim-row">
        <div class="sim-info">
          <span class="sim-tag">Ray Tracing</span>
          <h2>Geometric Optics</h2>
          <p>Solving the lens equation $\frac{1}{f} = \frac{1}{d_o} + \frac{1}{d_i}$. Real-time calculation of image distance and magnification.</p>
          <div id="ctrl-optics" class="controls"></div>
        </div>
        <div class="canvas-box">
          <div id="hud-optics" class="hud"></div>
          <canvas id="canvas-optics"></canvas>
        </div>
      </section>

      <section class="sim-row">
        <div class="sim-info">
          <span class="sim-tag">Statistical Mechanics</span>
          <h2>Ideal Gas Thermodynamics</h2>
          <p>Kinetic Theory simulation. Pressure arises from particle momentum transfer ($P \propto \bar{E_k}$).</p>
          <div id="ctrl-thermo" class="controls"></div>
        </div>
        <div class="canvas-box">
          <div id="hud-thermo" class="hud"></div>
          <canvas id="canvas-thermo"></canvas>
        </div>
      </section>

      <section class="sim-row">
        <div class="sim-info">
          <span class="sim-tag">Vector Math</span>
          <h2>Vector Addition</h2>
          <p>Visualizing vector summation $\vec{R} = \vec{A} + \vec{B}$ using the head-to-tail method on a Cartesian grid.</p>
          <div id="ctrl-vectors" class="controls"></div>
        </div>
        <div class="canvas-box">
          <div id="hud-vectors" class="hud"></div>
          <canvas id="canvas-vectors"></canvas>
        </div>
      </section>

    </div>
  </main>

  <footer>
    <div class="logo-box" style="margin: 0 auto 1rem; color:white;"><i class="fas fa-atom"></i></div>
    <h3>The Nouveau Way</h3>
    <p>Advanced Physics Simulation Platform</p>
    <p style="margin-top: 1rem; font-size: 0.85rem; color: var(--text-muted);">&copy; 2026 Mr Daniel Bishoy. Engineered for Excellence.</p>
  </footer>

<script>
/* =========================================
   UTILITIES & ENGINE
   ========================================= */
const SIMS = [];

function createControls(id, items) {
  const panel = document.getElementById(id);
  if(!panel) return;
  panel.innerHTML = '';

  items.forEach(item => {
    const group = document.createElement('div');
    group.className = 'ctrl-group';

    if (item.type === 'button') {
      const btn = document.createElement('button');
      btn.className = 'btn-primary';
      btn.innerText = item.label;
      btn.onclick = item.action;
      group.appendChild(btn);
    } else {
      const header = document.createElement('div');
      header.className = 'ctrl-header';
      const valSpan = document.createElement('span');
      valSpan.className = 'ctrl-val';
      valSpan.innerText = item.obj[item.prop].toFixed(item.prec||1);
      
      header.innerHTML = `<span>${item.label}</span>`;
      header.appendChild(valSpan);
      
      const input = document.createElement('input');
      input.type = 'range';
      input.min = item.min; input.max = item.max;
      input.step = item.step || (item.max - item.min)/100;
      input.value = item.obj[item.prop];
      
      input.oninput = (e) => {
        const v = parseFloat(e.target.value);
        item.obj[item.prop] = v;
        valSpan.innerText = v.toFixed(item.prec||1);
        if(item.onChange) item.onChange(v);
      };

      group.appendChild(header);
      group.appendChild(input);
    }
    panel.appendChild(group);
  });
}

// Fixed: Use HTML for dynamic HUD to avoid LaTeX flashing issues
function updateHUD(id, html) {
  const hud = document.getElementById('hud-' + id);
  if(hud) hud.innerHTML = html;
}

/* =========================================
   SIMULATIONS (Logic)
   ========================================= */

// 1. PROJECTILE
function initProjectile() {
  const canvas = document.getElementById('canvas-projectile');
  const parent = canvas.parentElement;
  const cfg = { v: 22, ang: 45 };
  
  const engine = Matter.Engine.create();
  const world = engine.world;
  const render = Matter.Render.create({
    canvas: canvas, engine: engine,
    options: { width: parent.clientWidth, height: parent.clientHeight, wireframes: false, background: 'transparent' }
  });
  
  Matter.World.add(world, Matter.Bodies.rectangle(parent.clientWidth/2, parent.clientHeight, parent.clientWidth, 40, { isStatic: true, render: {fillStyle: '#334155'} }));
  
  let projectiles = [];
  function fire() {
    const rad = cfg.ang * (Math.PI/180);
    const vx = cfg.v * Math.cos(rad);
    const vy = -cfg.v * Math.sin(rad);
    const p = Matter.Bodies.circle(50, parent.clientHeight-50, 10, { restitution: 0.6, render: {fillStyle: '#4cc9f0'} });
    Matter.Body.setVelocity(p, {x: vx, y: vy});
    Matter.World.add(world, p);
    projectiles.push({ body: p, trail: [] });
    if(projectiles.length > 5) Matter.World.remove(world, projectiles.shift().body);
  }

  createControls('ctrl-projectile', [
    { label: 'Velocity (m/s)', obj: cfg, prop: 'v', min: 10, max: 35 },
    { label: 'Angle (deg)', obj: cfg, prop: 'ang', min: 0, max: 90, prec: 0 },
    { type: 'button', label: 'FIRE CANNON', action: fire }
  ]);
  
  SIMS.push((dt, time) => {
    Matter.Engine.update(engine, dt*1000);
    Matter.Render.world(render);
    const ctx = canvas.getContext('2d');
    projectiles.forEach(p => {
      if(time % 0.1 < dt) p.trail.push({...p.body.position});
      ctx.beginPath(); ctx.strokeStyle = 'rgba(76, 201, 240, 0.4)';
      p.trail.forEach((pt, i) => i===0 ? ctx.moveTo(pt.x,pt.y) : ctx.lineTo(pt.x,pt.y));
      ctx.stroke();
    });
    // Draw Cannon
    ctx.save(); ctx.translate(50, parent.clientHeight-50);
    ctx.rotate(-cfg.ang * Math.PI/180);
    ctx.fillStyle = '#94a3b8'; ctx.fillRect(0, -10, 50, 20); ctx.restore();
    
    // HUD: Using HTML entities for symbols
    updateHUD('projectile', `g = 9.81 m/s²<br>Active: ${projectiles.length}`);
  });
}

// 2. WAVES
function initWave() {
  const canvas = document.getElementById('canvas-wave');
  const ctx = canvas.getContext('2d');
  const cfg = { f: 8, sep: 80 };
  
  createControls('ctrl-wave', [
    { label: 'Frequency (Hz)', obj: cfg, prop: 'f', min: 2, max: 15 },
    { label: 'Separation (px)', obj: cfg, prop: 'sep', min: 20, max: 200 }
  ]);
  
  SIMS.push((dt, time) => {
    canvas.width = canvas.parentElement.clientWidth; canvas.height = canvas.parentElement.clientHeight;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width, canvas.height);
    const cx = canvas.width/2, cy = canvas.height/2;
    const wl = 300 / cfg.f;
    const offset = (time * 80) % wl;
    ctx.lineWidth = 2;
    for(let i=0; i<2; i++) {
        const x = cx + (i===0?-1:1)*cfg.sep/2;
        const col = i===0 ? '67, 97, 238' : '76, 201, 240';
        for(let r=offset; r<canvas.width; r+=wl) {
            ctx.strokeStyle = `rgba(${col}, ${Math.max(0, 1 - r/400)})`;
            ctx.beginPath(); ctx.arc(x, cy, r, 0, 6.28); ctx.stroke();
        }
    }
    updateHUD('wave', `λ = ${wl.toFixed(1)} px`);
  });
}

// 3. ORBIT (3D)
function initOrbit() {
  const canvas = document.getElementById('canvas-orbit');
  const parent = canvas.parentElement;
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(50, parent.clientWidth/parent.clientHeight, 0.1, 1000);
  camera.position.set(0, 20, 30); camera.lookAt(0,0,0);
  const renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
  renderer.setSize(parent.clientWidth, parent.clientHeight);
  
  const star = new THREE.Mesh(new THREE.SphereGeometry(2,32,32), new THREE.MeshBasicMaterial({color: 0xffaa00}));
  const planet = new THREE.Mesh(new THREE.SphereGeometry(0.8,32,32), new THREE.MeshNormalMaterial());
  scene.add(star); scene.add(planet); scene.add(new THREE.GridHelper(50,50,0x333333,0x111111));
  
  let cfg = { m: 2.0 }, theta = 0;
  createControls('ctrl-orbit', [{ label: 'Star Mass (M☉)', obj: cfg, prop: 'm', min: 0.5, max: 5 }]);
  
  SIMS.push((dt) => {
    renderer.setSize(parent.clientWidth, parent.clientHeight);
    camera.aspect = parent.clientWidth/parent.clientHeight; camera.updateProjectionMatrix();
    const r = 12, v = Math.sqrt(cfg.m/r) * 2;
    theta += v * dt;
    planet.position.set(r*Math.cos(theta), 0, r*Math.sin(theta));
    planet.rotation.y += dt;
    renderer.render(scene, camera);
    updateHUD('orbit', `v = ${v.toFixed(2)} km/s`);
  });
}

// 4. CIRCUIT
function initCircuit() {
  const canvas = document.getElementById('canvas-circuit');
  const ctx = canvas.getContext('2d');
  const cfg = { v: 9, r: 10 };
  let charge = 0;
  
  createControls('ctrl-circuit', [
    { label: 'Voltage (V)', obj: cfg, prop: 'v', min: 0, max: 24 },
    { label: 'Resistance (Ω)', obj: cfg, prop: 'r', min: 1, max: 50 }
  ]);
  
  SIMS.push((dt) => {
    canvas.width = canvas.parentElement.clientWidth; canvas.height = canvas.parentElement.clientHeight;
    const cx = canvas.width/2, cy = canvas.height/2;
    const I = cfg.v / cfg.r; charge += I * dt * 50;
    
    ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,canvas.width, canvas.height);
    // Wire
    ctx.strokeStyle = '#64748b'; ctx.lineWidth = 4; ctx.strokeRect(cx-120, cy-80, 240, 160);
    // Battery
    ctx.fillStyle='#ef4444'; ctx.fillRect(cx-130, cy-25, 20, 5);
    ctx.fillStyle='#3b82f6'; ctx.fillRect(cx-130, cy+20, 20, 5);
    // Bulb
    ctx.fillStyle='#0f172a'; ctx.fillRect(cx+110, cy-30, 20, 60);
    const bright = Math.min(1, I/1.5);
    ctx.fillStyle=`rgba(253, 224, 71, ${0.2+bright})`; ctx.shadowColor='#eab308'; ctx.shadowBlur=bright*30;
    ctx.beginPath(); ctx.arc(cx+120, cy, 20, 0, 6.28); ctx.fill(); ctx.shadowBlur=0;
    
    if(I > 0.1) {
      ctx.fillStyle = '#fbbf24';
      for(let i=0; i<16; i++) {
        let d = (i*50 + charge)%800;
        let x,y;
        if(d<240) {x=cx-120+d; y=cy-80;} else if(d<400) {x=cx+120; y=cy-80+(d-240);}
        else if(d<640) {x=cx+120-(d-400); y=cy+80;} else {x=cx-120; y=cy+80-(d-640);}
        ctx.beginPath(); ctx.arc(x,y,3,0,6.28); ctx.fill();
      }
    }
    updateHUD('circuit', `I = ${I.toFixed(2)} A`);
  });
}

// 5. EM FIELDS (FIXED PHYSICS: Solenoid Model)
function initEM() {
  const canvas = document.getElementById('canvas-em');
  const ctx = canvas.getContext('2d');
  const cfg = { i: 2.0 };
  
  createControls('ctrl-em', [{ label: 'Current (A)', obj: cfg, prop: 'i', min: -5, max: 5 }]);
  
  SIMS.push((dt, time) => {
    const w = canvas.parentElement.clientWidth;
    const h = canvas.parentElement.clientHeight;
    canvas.width = w; canvas.height = h;
    const cx = w/2, cy = h/2;
    
    ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,w,h);
    
    // Draw Solenoid Cutaway (Core & Windings)
    ctx.fillStyle = '#1e293b'; ctx.fillRect(cx-70, cy-40, 140, 80); 
    ctx.fillStyle = '#f59e0b';
    for(let x = cx-65; x < cx+65; x+=10) {
        ctx.fillRect(x, cy-45, 6, 10); // Top coil section
        ctx.fillRect(x, cy+35, 6, 10); // Bottom coil section
    }

    // Visualize Field Lines
    const I = cfg.i;
    if(Math.abs(I) > 0.1) {
       const speed = time * I * 2.0; 
       const dir = Math.sign(I);
       ctx.lineWidth = 2;
       
       // Draw loops: 0=Center(Straight), +/- = Loops
       [0, 1, 2, 3, 4].forEach(k => {
           const off = k - 2; // -2, -1, 0, 1, 2
           const yBase = off * 15; // Vertical spacing inside the core
           
           // Geometry Parameters
           const halfL = 80;
           const cpOffset = 100 + Math.abs(off)*30;
           const yReturn = (off === 0) ? (Math.random()>0.5?130:-130) : (off > 0 ? 120 + off*15 : -120 + off*15); 
           
           // A. Draw Field Line Path
           ctx.beginPath();
           ctx.strokeStyle = `rgba(76, 201, 240, ${0.8 - Math.abs(off)*0.15})`;
           
           if(off === 0) {
               // Center line is effectively straight infinite
               ctx.moveTo(0, cy); ctx.lineTo(w, cy);
           } else {
               // Inside (Straight)
               ctx.moveTo(cx - halfL, cy + yBase);
               ctx.lineTo(cx + halfL, cy + yBase);
               // Outside Return (Bezier Loop)
               ctx.bezierCurveTo(cx + halfL + cpOffset, cy + yBase, cx + halfL + cpOffset, cy + yReturn, cx, cy + yReturn);
               ctx.bezierCurveTo(cx - halfL - cpOffset, cy + yReturn, cx - halfL - cpOffset, cy + yBase, cx - halfL, cy + yBase);
           }
           ctx.stroke();
           
           // B. Draw Moving Particles
           let t_geom = (speed + k * 0.2) % 1; 
           if(t_geom < 0) t_geom += 1;
           // If dir is negative, we interpret t differently visually
           let pt = (dir > 0) ? t_geom : 1 - t_geom;

           let px, py;
           
           if(off === 0) {
               px = (pt * w); py = cy; // Simple linear motion
           } else {
               // Map 0..0.3 to Straight Inside, 0.3..1.0 to Loop Outside
               if(pt < 0.3) {
                   const lT = pt / 0.3;
                   px = (cx - halfL) + lT * (2 * halfL);
                   py = cy + yBase;
               } else {
                   const bT = (pt - 0.3) / 0.7;
                   // Approximate ellipse path for particle
                   const ang = bT * Math.PI; // 0 to PI
                   // For upper loops (off<0), yReturn is negative relative to center
                   // We need to interpolate between (cx+halfL, yBase) -> (cx-halfL, yBase) via yReturn
                   const x_amp = halfL + cpOffset * 0.6;
                   const y_amp = (yReturn - yBase);
                   
                   px = cx + x_amp * Math.cos(ang); // Goes + to -
                   // Adjust Y to arc correctly
                   py = cy + yBase + y_amp * Math.sin(ang); 
               }
           }
           
           ctx.fillStyle = '#fff';
           ctx.beginPath(); ctx.arc(px, py, 2.5, 0, 6.28); ctx.fill();
       });
    }
    
    // HUD: Use HTML Entity for Proportional Symbol
    updateHUD('em', `B &propto; ${Math.abs(I).toFixed(1)} T`);
  });
}

// 6. HARMONIC (RK4)
function initHarmonic() {
  const canvas = document.getElementById('canvas-harmonic');
  const ctx = canvas.getContext('2d');
  const cfg = { k: 10, c: 0.5 };
  let s = { x: 2, v: 0 };
  
  createControls('ctrl-harmonic', [
    { label: 'Stiffness k', obj: cfg, prop: 'k', min: 1, max: 20 },
    { label: 'Damping c', obj: cfg, prop: 'c', min: 0, max: 2, step: 0.1 },
    { type: 'button', label: 'Kick Mass', action: () => s.v = 8 }
  ]);
  
  SIMS.push((dt) => {
    canvas.width = canvas.parentElement.clientWidth; canvas.height = canvas.parentElement.clientHeight;
    const fv = (x, v) => -cfg.k*x - cfg.c*v;
    let k1v = fv(s.x, s.v), k1x = s.v;
    let k2v = fv(s.x+0.5*dt*k1x, s.v+0.5*dt*k1v), k2x = s.v+0.5*dt*k1v;
    let k3v = fv(s.x+0.5*dt*k2x, s.v+0.5*dt*k2v), k3x = s.v+0.5*dt*k2v;
    let k4v = fv(s.x+dt*k3x, s.v+dt*k3v), k4x = s.v+dt*k3v;
    s.x += (dt/6)*(k1x+2*k2x+2*k3x+k4x); s.v += (dt/6)*(k1v+2*k2v+2*k3v+k4v);
    
    ctx.clearRect(0,0,canvas.width,canvas.height);
    const cx = canvas.width/2, cy = 50, bobY = cy+150+s.x*40;
    ctx.beginPath(); ctx.moveTo(cx,cy);
    for(let i=0; i<=20; i++) ctx.lineTo(cx+(i%2?-10:10), cy+(i/20)*(bobY-cy));
    ctx.strokeStyle='#94a3b8'; ctx.stroke();
    ctx.fillStyle='#4361ee'; ctx.beginPath(); ctx.arc(cx,bobY,20,0,6.28); ctx.fill();
    updateHUD('harmonic', `x = ${s.x.toFixed(2)} m`);
  });
}

// 7. OPTICS
function initOptics() {
  const canvas = document.getElementById('canvas-optics');
  const ctx = canvas.getContext('2d');
  const cfg = { f: 100, do: 200 };
  createControls('ctrl-optics', [
    { label: 'Focal Len', obj: cfg, prop: 'f', min: 50, max: 150 },
    { label: 'Obj Dist', obj: cfg, prop: 'do', min: 60, max: 400 }
  ]);
  function arrow(x,y,h,c) {
    ctx.strokeStyle=c; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x,y+h); ctx.stroke();
    ctx.fillStyle=c; ctx.beginPath(); ctx.moveTo(x,y+h); ctx.lineTo(x-5,y+h+(h>0?-10:10)); ctx.lineTo(x+5,y+h+(h>0?-10:10)); ctx.fill();
  }
  SIMS.push(() => {
    canvas.width = canvas.parentElement.clientWidth; canvas.height = canvas.parentElement.clientHeight;
    ctx.clearRect(0,0,canvas.width,canvas.height);
    const cx = canvas.width/2, cy = canvas.height/2;
    const di = (cfg.f*cfg.do)/(cfg.do-cfg.f), m = -di/cfg.do, hi = m*60;
    // Lens
    ctx.strokeStyle='#4cc9f0'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(cx,cy-120); ctx.lineTo(cx,cy+120); ctx.stroke();
    ctx.strokeStyle='#555'; ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(0,cy); ctx.lineTo(canvas.width,cy); ctx.stroke();
    // Foci
    ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(cx-cfg.f,cy,3,0,6.28); ctx.fill(); ctx.beginPath(); ctx.arc(cx+cfg.f,cy,3,0,6.28); ctx.fill();
    arrow(cx-cfg.do, cy, -60, '#22c55e'); arrow(cx+di, cy, hi, '#facc15');
    // Rays
    ctx.strokeStyle='rgba(255,255,255,0.3)';
    ctx.beginPath(); ctx.moveTo(cx-cfg.do, cy-60); ctx.lineTo(cx, cy-60); ctx.lineTo(cx+di, cy+hi); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(cx-cfg.do, cy-60); ctx.lineTo(cx+di, cy+hi); ctx.stroke();
    updateHUD('optics', `Mag m = ${m.toFixed(2)}x`);
  });
}

// 8. THERMO
function initThermo() {
  const canvas = document.getElementById('canvas-thermo');
  const parent = canvas.parentElement;
  const cfg = { t: 1.0 };
  const engine = Matter.Engine.create(); engine.world.gravity.y = 0;
  const w = parent.clientWidth, h = parent.clientHeight;
  const wall = { isStatic: true, render: {fillStyle: '#fff'} };
  Matter.World.add(engine.world, [
    Matter.Bodies.rectangle(w/2, 0, w, 20, wall), Matter.Bodies.rectangle(w/2, h, w, 20, wall),
    Matter.Bodies.rectangle(0, h/2, 20, h, wall), Matter.Bodies.rectangle(w, h/2, 20, h, wall)
  ]);
  const parts = [];
  for(let i=0; i<30; i++) {
    const p = Matter.Bodies.circle(Math.random()*w, Math.random()*h, 5, { restitution: 1, friction: 0, frictionAir: 0, render: {fillStyle: '#ef4444'} });
    Matter.Body.setVelocity(p, {x:(Math.random()-0.5)*5, y:(Math.random()-0.5)*5});
    parts.push(p); Matter.World.add(engine.world, p);
  }
  const render = Matter.Render.create({ canvas, engine, options: { width: w, height: h, wireframes: false, background: 'transparent' } });
  
  createControls('ctrl-thermo', [{ label: 'Temp T', obj: cfg, prop: 't', min: 0.5, max: 3, step: 0.1 }]);
  
  SIMS.push((dt) => {
    Matter.Engine.update(engine, dt*1000); Matter.Render.world(render);
    let ke = 0;
    parts.forEach(p => {
      let s = p.speed, scale = 1 + (3*cfg.t - s)*0.05;
      if(s<0.1) Matter.Body.setVelocity(p, {x:1,y:1});
      Matter.Body.setVelocity(p, {x:p.velocity.x*scale, y:p.velocity.y*scale});
      ke += 0.5*p.mass*s*s;
    });
    updateHUD('thermo', `P &propto; ${ke.toFixed(0)} Pa`);
  });
}

// 9. VECTORS
function initVectors() {
  const canvas = document.getElementById('canvas-vectors');
  const ctx = canvas.getContext('2d');
  const cfg = { ax: 100, ay: -50, bx: 50, by: 100 };
  createControls('ctrl-vectors', [
    { label: 'Ax', obj: cfg, prop: 'ax', min: -150, max: 150, prec:0 },
    { label: 'Ay', obj: cfg, prop: 'ay', min: -150, max: 150, prec:0 },
    { label: 'Bx', obj: cfg, prop: 'bx', min: -150, max: 150, prec:0 },
    { label: 'By', obj: cfg, prop: 'by', min: -150, max: 150, prec:0 }
  ]);
  function arrow(x,y,dx,dy,c,l) {
    ctx.strokeStyle=c; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x+dx,y+dy); ctx.stroke();
    let a=Math.atan2(dy,dx); ctx.fillStyle=c;
    ctx.beginPath(); ctx.moveTo(x+dx,y+dy); ctx.lineTo(x+dx-12*Math.cos(a-0.5),y+dy-12*Math.sin(a-0.5)); ctx.lineTo(x+dx-12*Math.cos(a+0.5),y+dy-12*Math.sin(a+0.5)); ctx.fill();
    ctx.font='bold 14px sans'; ctx.fillText(l, x+dx/2, y+dy/2-10);
  }
  SIMS.push(() => {
    canvas.width=canvas.parentElement.clientWidth; canvas.height=canvas.parentElement.clientHeight;
    ctx.fillStyle='#0f172a'; ctx.fillRect(0,0,canvas.width,canvas.height);
    const cx=canvas.width/2, cy=canvas.height/2;
    ctx.strokeStyle='#333'; ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(cx,0); ctx.lineTo(cx,canvas.height); ctx.stroke(); ctx.beginPath(); ctx.moveTo(0,cy); ctx.lineTo(canvas.width,cy); ctx.stroke();
    arrow(cx,cy,cfg.ax,-cfg.ay,'#ef4444','A'); arrow(cx+cfg.ax,cy-cfg.ay,cfg.bx,-cfg.by,'#3b82f6','B');
    arrow(cx,cy,cfg.ax+cfg.bx,-(cfg.ay+cfg.by),'#22c55e','R');
    updateHUD('vectors', `|R| = ${Math.sqrt((cfg.ax+cfg.bx)**2+(cfg.ay+cfg.by)**2).toFixed(1)}`);
  });
}

/* =========================================
   INITIALIZATION
   ========================================= */
document.addEventListener("DOMContentLoaded", () => {
  // 1. Render Static LaTeX
  renderMathInElement(document.body, {
    delimiters: [
      {left: '$$', right: '$$', display: true},
      {left: '$', right: '$', display: false}
    ]
  });

  // 2. Animate Entry
  anime({
    targets: '.animate-in', opacity: [0, 1], translateY: [20, 0],
    delay: anime.stagger(100), easing: 'easeOutQuad', duration: 800
  });

  // 3. Start Sims
  initProjectile();
  initWave();
  initOrbit();
  initCircuit();
  initEM();
  initHarmonic();
  initOptics();
  initThermo();
  initVectors();

  // 4. Global Loop
  let last = 0;
  let time = 0;
  function loop(now) {
    const dt = Math.min((now - last)/1000, 0.05);
    last = now;
    time += dt;
    SIMS.forEach(sim => sim(dt, time));
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
});
</script>
</body>
</html>